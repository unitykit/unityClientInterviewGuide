# 摄像机

![img](https://cdn.nlark.com/yuque/0/2024/png/35926903/1717652654217-250d3acd-583a-4d68-aa04-3a719dd9623d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_56iL5bqP5ZGYIC0g6Zi_5biD5ouJ%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

### 1. Camera组件的主要作用是什么？

- **答案**：Camera是Unity中用于渲染场景的组件，负责将3D世界转换为2D屏幕图像。
- **关键属性**： 

- `Clear Flags`：决定如何清除屏幕（Skybox/Solid Color/Depth Only/Don't Clear）。
- `Culling Mask`：控制哪些图层（Layer）会被渲染。

### 2. 如何实现分屏或多摄像机渲染？

- **答案**：通过调整`Viewport Rect`属性划分屏幕区域。例如： 

```csharp
// 左半屏
camera1.rect = new Rect(0, 0, 0.5f, 1);  
// 右半屏
camera2.rect = new Rect(0.5f, 0, 0.5f, 1);
```

- **原理**：每个摄像机独立渲染到指定视口，最终合成画面。

### 3. Camera的Clipping Planes（剪裁平面）是什么？如何设置？

- **答案**： 

- `Near`：最近渲染距离，过小会导致近处物体裁剪（如UI消失）。
- `Far`：最远渲染距离，过大会增加渲染负担。

- **注意事项**： 

- 地形渲染需确保`Far`足够大，但避免包含无关物体。

### 4. 如何实现摄像机跟随角色且平滑移动？

- **答案**：在`LateUpdate`中更新摄像机位置，避免画面抖动： 

```csharp
void LateUpdate() {
    transform.position = Vector3.Lerp(transform.position, target.position + offset, 0.1f);
}
```

- **优化技巧**： 

- 使用`Cinemachine`插件实现复杂跟随逻辑（如轨道、阻尼）。

### 5. 如何实现景深（Depth of Field）效果？

- **答案**： 

- **URP/HDRP**：使用`Volume`系统的`Depth Of Field`覆盖。
- **内置管线**：通过后处理Shader模拟焦点模糊。

- **参数解析**： 

- `Focus Distance`：焦点距离。
- `Aperture`：光圈大小，控制模糊强度。

### 6. 如何减少摄像机的渲染开销？

- **答案**： 

1. **禁用不必要的摄像机**：非活动摄像机设为`enabled = false`。
2. **分层渲染**：通过`Culling Mask`排除无关图层。
3. **Occlusion Culling**：烘焙静态物体遮挡数据。

### 7. 为什么摄像机会渲染粉色或黑色画面？

- **原因**： 

- **粉色**：未找到渲染管线材质（如未正确迁移到URP）。
- **黑色**：`Clear Flags`设为`Solid Color`且背景色为黑色，或未放置光源。

### 8. 如何让摄像机不渲染UI？

- **答案**： 

- 将UI Canvas的`Render Mode`设为`Screen Space - Overlay`，或调整UI图层与摄像机的`Culling Mask`。

### 9. 如何实现摄像机震动（Screen Shake）？

**适用场景**：爆炸、撞击等特效。

```js
// 相机震动协程：通过随机偏移位置模拟震动效果
IEnumerator Shake(float duration, float magnitude) {
    // 记录初始位置，震动结束后恢复
    Vector3 originalPos = transform.localPosition;
    float elapsed = 0; // 计时器
    
    // 震动循环：在持续时间内不断更新位置
    while (elapsed < duration) {
        // 生成随机偏移量（单位圆内随机方向 * 震动强度）
        float x = Random.Range(-1f, 1f) * magnitude;
        float y = Random.Range(-1f, 1f) * magnitude;
        
        // 应用新位置（保持Z轴不变）
        transform.localPosition = new Vector3(x, y, originalPos.z);
        
        // 累计时间（使用deltaTime保证帧率无关）
        elapsed += Time.deltaTime;
        
        // 暂停协程至下一帧继续执行
        yield return null;
    }
    
    // 恢复初始位置（避免结束时的位置偏移）
    transform.localPosition = originalPos;
}
```
