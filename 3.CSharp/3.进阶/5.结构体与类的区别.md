# 结构体与类的区别

类和结构在设计和使用时有不同的考虑因素，类适合表示复杂的对象和行为，支持继承和多态性，而结构则更适合表示轻量级数据和值类型，以提高性能并避免引用的管理开销。

类和结构有以下几个基本的不同点：

## 区别

**值类型/引用类型**

- **结构是值类型（Value Type）：** 结构是值类型，它们在栈上分配内存，而不是在堆上。当将结构实例传递给方法或赋值给另一个变量时，将复制整个结构的内容。
- **类是引用类型（Reference Type）：** 类是引用类型，它们在堆上分配内存。当将类实例传递给方法或赋值给另一个变量时，实际上是传递引用（内存地址）而不是整个对象的副本。

**继承和多态性**

- **结构不能继承：** 结构不能继承其他结构或类，也不能作为其他结构或类的基类。
- **类支持继承：** 类支持继承和多态性，可以通过派生新类来扩展现有类的功能。

**默认构造函数**

- **结构不能有无参数的构造函数：** 结构不能包含无参数的构造函数。
- **类可以有无参数的构造函数：** 类可以包含无参数的构造函数，如果没有提供构造函数，系统会提供默认的无参数构造函数。

**赋值行为**

- 类型为类的变量在赋值时存储的是引用，因此两个变量指向同一个对象。
- 结构变量在赋值时会复制整个结构，因此每个变量都有自己的独立副本。

**传递方式**

- 类型为类的对象在方法调用时通过引用传递，这意味着在方法中对对象所做的更改会影响到原始对象。
- 结构对象通常通过值传递，这意味着传递的是结构的副本，而不是原始结构对象本身。因此，在方法中对结构所做的更改不会影响到原始对象。

**可空性**

- **结构体是值类型，不能直接设置为** **null****：**因为 null 是引用类型的默认值，而不是值类型的默认值。如果你需要表示结构体变量的缺失或无效状态，可以使用 Nullable\<T\> 或称为 T? 的可空类型。
- **类默认可为null：** 类的实例默认可以为 `null`，因为它们是引用类型。

**性能和内存分配**

- **结构通常更轻量：** 由于结构是值类型且在栈上分配内存，它们通常比类更轻量，适用于简单的数据表示。
- **类可能有更多开销：** 由于类是引用类型，可能涉及更多的内存开销和管理。

## 应用场景

首先明确，类的对象是存储在堆空间中，结构存储在栈中。堆空间大，但访问速度较慢，栈空间小，访问速度相对更快。故而，当我们描述一个轻量级对象的时候，结构可提高效率，成本更低。当然，这也得从需求出发，假如我们在传值的时候希望传递的是对象的引用地址而不是对象的拷贝，就应该使用类了。

- 结构是值类型，它在栈中分配空间；而类是引用类型，它在堆中分配空间，栈中保存的只是引用。 
- 结构类型直接存储成员数据，让其他类的数据位于堆中，位于栈中的变量保存的是指向堆中数据对象的引用。

C# 中的简单类型，如int、double、bool等都是结构类型。如果需要的话，甚至可以使用结构类型结合运算符运算重载，再为 C# 语言创建出一种新的值类型来。

由于结构是值类型，并且直接存储数据，因此在一个对象的主要成员为数据且数据量不大的情况下，使用结构会带来更好的性能。

因为结构是值类型，因此在为结构分配内存，或者当结构超出了作用域被删除时，性能会非常好，因为他们将内联或者保存在堆栈中。当把一个结构类型的变量赋值给另一个结构时，对性能的影响取决于结构的大小，如果结构的数据成员非常多而且复杂，就会造成损失，接下来使用一段代码来说明这个问题。

**结构和类的适用场合分析**

-  当堆栈的空间很有限，且有大量的逻辑对象时，创建类要比创建结构好一些
-  对于点、矩形和颜色这样的轻量对象，假如要声明一个含有许多个颜色对象的数组，则CLR需要为每个对象分配内存，在这种情况下，使用结构的成本较低
- 在表现抽象和多级别的对象层次时，类是最好的选择，因为结构不支持继承。
- 大多数情况下，目标类型只是含有一些数据，或者以数据为主
