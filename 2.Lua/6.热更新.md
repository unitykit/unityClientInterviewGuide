# 面试题

## Lua 为什么能够热更新

Lua是一种解释型语言，代码在运行时通过Lua虚拟机逐行解释执行，无需预先编译成机器码。这种动态性允许在程序运行期间直接加载、修改或替换脚本内容（如通过`loadfile`、`dofile`等函数），而无需重启应用。相比之下，C#等静态语言需要编译后执行，运行时无法直接修改已编译的代码逻辑。

Lua通过模块化设计（如`require`加载模块）和全局表（如`_G`）管理变量和函数。热更新时，只需替换全局表中的函数或表引用即可生效。例如，新脚本可以重新定义`_G["Player.Move"]`函数，运行时所有调用该函数的地方会自动指向新逻辑，实现无缝替换

Unity通过插件（如XLua、ToLua）集成Lua虚拟机，构建了C#与Lua的桥梁：

- **XLua**：腾讯开源的框架，支持将C#方法标记为`[Hotfix]`，允许Lua脚本动态覆盖原C#逻辑（如`xlua.hotfix(CS.Player, 'Move', function() ... end)`），实现C#层面的热修复。
- **AssetBundle支持**：Lua脚本可打包为AssetBundle资源，通过动态下载并加载到内存，绕过应用商店的审核流程，直接更新游戏逻辑。

# Lua与C#交互

**方法**：

- **C# → Lua**：通过`XLua`或`ToLua`的`DoString()`执行Lua代码。
- **Lua → C#**： 

```csharp
local go = CS.UnityEngine.GameObject("Obj") -- 创建GameObject
go:AddComponent(typeof(CS.UnityEngine.Rigidbody)) -- 添加组件
```

# Lua热更

面试题： Lua 怎么热更的？

1. lua做热更时，通过版本对比，md5文件差异比较，把更新的lua代码所在的ab包下载下来;
2. 当最新代码下载下来以后，我们首先去下载目录下加载lua代码所在的ab包，如果没有，就到本地StreammingAssets目录下加载，如果没有，就报错。
3. Lua 虚拟机添加 customloader, 当有require来加载lua代码的时候，我们就从来到 customloader的函数，这个函数从Lua代码所在的ab包里面，根据lua文件路径，把文本资源读出出来，并装载到lua虚拟机里面执行。

由于每次都是优先从下载目录下加载lua, ab包，所以热更的时候，能加载执行到最新代码。

# Lua实现简易热更新

**Lua 语言的热更新通常是指在程序运行时动态加载和执行新的 Lua 代码，而不需要重启整个程序。**

**这种特性使得 Lua 在许多游戏和实时系统中非常受欢迎，因为它允许开发者在不中断用户体验的情况下修复问题或添加新功能。**

实现 Lua 的热更新通常涉及以下几个步骤：

1. 加载新代码：使用 Lua 的 loadfile 或 loadstring 函数来加载新的 Lua 脚本文件或字符串。
2. 执行新代码：使用 pcall 或其他错误处理机制来安全地执行加载的代码。
3. 更新对象或状态：如果新的代码修改了现有对象或状态，确保这些更改在全局范围内可见，并且与现有代码兼容。
4. 错误处理：确保有适当的错误处理机制，以便在加载或执行新代码时出现问题时能够优雅地恢复。

下面是一个简单的示例，展示了如何在 Lua 中实现基本的热更新功能：

```lua
-- 假设我们有一个全局的 table，用于存储游戏状态  
gameState = {  
    score = 0,  
    level = 1,  
}  
  
-- 加载并执行新的 Lua 脚本文件  
function hot_update(filename)  
    local chunk, err = loadfile(filename)  
    if not chunk then  
        print("Error loading file:", err)  
        return  
    end  
      
    -- 使用 pcall 来安全地执行代码  
    local success, err = pcall(chunk)  
    if not success then  
        print("Error executing code:", err)  
    else  
        print("Hot update successful!")  
    end  
end  
  
-- 假设我们有一个新的 Lua 脚本文件（new_code.lua），它修改了游戏状态  
-- new_code.lua 的内容可能是这样的：  
-- gameState.score = gameState.score + 10  
-- gameState.level = gameState.level + 1  
  
-- 在主程序中调用 hot_update 函数来加载和执行新的代码  
hot_update("new_code.lua")  
  
-- 检查游戏状态是否已更新  
print("Score:", gameState.score)  
print("Level:", gameState.level)
```

请注意，这个示例非常基础，并且没有考虑许多实际应用中可能需要的复杂性和安全性问题。

在真实的项目中，需要处理更复杂的依赖关系、错误恢复策略以及可能的性能影响。

此外，如果你正在使用像 LuaJIT 这样的 Lua 解释器，你可能还需要考虑如何利用其提供的特定功能来优化热更新的性能。

例如，LuaJIT 提供了一种称为“保存状态”的机制，它允许你保存 Lua 解释器的当前状态，并在稍后恢复它，这可以用于实现更高效的热更新策略。

# Lua热更文件

**面试题： Lua热更文件时，文件是重写的，还是只写一部分?**

​	热更分为资源更新和代码更新，资源更新的颗粒度是基于ab包的，是基于一个个资源包来进行下载和替换。

做代码热更新的时候,如果热更代码被打入了ab包，那么下载的时候，也是整个代码所在的ab包一起下载。如果热更代码是单独部署的，我们就可以基于对应的文件颗粒度来下载替换。

一般做lua热更新的时候，代码打成ab包后，可能只有几百k,并不很大,那么我们打一个ab包就可以了。如果lua代码打包成ab包后很大，我们可以考虑把lua代码分成几个ab包，这样下次热更的时候，就是基于lua代码所在的ab包来热更。

对于其它热更技术也类似。热更代码是打一个ab包，还是打多个ab包，完全取决于代码ab包的大小。

# 战斗系统架构设计

**分层模型**

1. **功能层**：组件化模块（动画、伤害计算）
2. **实体层**：`Character`基类管理组件，`Player/Enemy`子类绑定数据
3. **操作层**：事件驱动（UI、网络事件触发战斗逻辑）
