# 元表

在Lua中，元表（metatable）和元方法（metamethod）是一种强大的机制，用于定义对象（在Lua中，几乎所有值都可以视为对象）之间操作的行为。元表是一个普通的Lua表，它可以包含一系列的键，这些键对应于特定的操作，而它们的值则是当这些操作应用于某个值时应该调用的函数。这些特定的操作就被称为元方法。

### 元表（Metatable）

**概念**

元表是一个Lua表，它可以被关联到一个或多个Lua值上。当Lua尝试对某个值执行一个操作时，如果这个值有一个关联的元表，并且这个元表中有一个与这个操作相对应的键，Lua就会调用这个键对应的函数（即元方法）来执行这个操作，而不是执行默认的操作。Lua的元表（metatable）是一个强大的特性，它允许你改变Lua中基本操作的默认行为。元表是一个用于存储关于某个值（通常是table）的额外信息的table。你可以通过元表来定义或修改表（table）的行为，比如定义如何比较两个表，如何对表进行加法运算等。

以下是对Lua元表的详细说明，并附带代码示例：

##### 设置和获取元表

你可以使用setmetatable函数为一个table设置元表，使用getmetatable函数来获取一个table的元表。

```lua
-- 创建一个普通的table  
local t = {}  
  
-- 创建一个新的table，作为元表  
local mt = {}  
  
-- 设置t的元表为mt  
setmetatable(t, mt)  
  
-- 获取t的元表  
local retrieved_mt = getmetatable(t)  
print(retrieved_mt == mt)  -- 输出：true
```

##### 使用元表中的__index字段

__index字段用于当访问table中不存在的字段时。你可以定义__index为一个函数或一个table，Lua会调用这个函数或在该table中查找缺失的字段。

```lua
local t = {}  
local mt = {}  
  
-- 设置__index字段为一个返回默认值的函数  
mt.__index = function(t, key)  
    return "default value for " .. key  
end  
  
setmetatable(t, mt)  
  
print(t.some_nonexistent_key)  -- 输出：default value for some_nonexistent_key
```

##### 使用元表中的__newindex字段

__newindex字段用于当给一个table中不存在的字段赋值时。与__index类似，你可以定义__newindex为一个函数或一个table。

```lua
local t = {}  
local mt = {}  
local backup = {}  
  
-- 设置__newindex字段为一个函数，该函数将新键值对存储在backup中  
mt.__newindex = function(t, key, value)  
    backup[key] = value  
end  
  
setmetatable(t, mt)  
  
t.new_key = "new value"  
print(t.new_key)  -- 输出：nil，因为t中没有new_key  
print(backup.new_key)  -- 输出：new value，因为new键值对存储在backup中
```

##### 使用元表中的其他字段

除了__index和__newindex，元表还可以包含其他字段来改变特定操作的行为。例如：

- __add、__sub、__mul、__div等用于定义算术运算。
- __eq、__lt等用于定义比较运算。
- __tostring用于定义如何将值转换为字符串。
- __call用于定义如何将table当作函数来调用。

```lua
-- 定义一个分数类  
local Fraction = {}  
Fraction.__index = Fraction  
  
function Fraction.create(numerator, denominator)  
    local frac = {}  
    setmetatable(frac, Fraction)  
    frac.numerator = numerator  
    frac.denominator = denominator or 1  
    return frac  
end  
  
-- 定义加法运算  
function Fraction:__add(other)  
    local new_numerator = self.numerator * other.denominator + self.denominator * other.numerator  
    local new_denominator = self.denominator * other.denominator  
    return Fraction.create(new_numerator, new_denominator)  
end  
  
-- 定义转换为字符串的方法  
function Fraction:__tostring()  
    return self.numerator .. "/" .. self.denominator  
end  
  
-- 创建两个分数并相加  
local frac1 = Fraction.create(1, 2)  
local frac2 = Fraction.create(1, 4)  
local sum = frac1 + frac2  -- 使用元表中的__add字段  
print(sum)  -- 输出：3/4，因为1/2 + 1/4 = 3/4
```

这个示例展示了如何使用元表来定义分数类的加法运算和转换为字符串的方法。当你尝试对两个分数进行加法运算时，Lua会查找它们的元表，并在其中找到__add字段，然后调用该函数来执行加法运算。同样地，当你尝试将一个分数转换为字符串时，Lua会在元表中找到__tostring字段并调用它。

##### 元方法（Metamethod）

1. 元方法是元表中的函数，它们定义了当对某个值执行特定操作时应该发生的行为。
2. 元方法的名称通常是以两个下划线（`__`）开头的字符串，后跟一个描述操作的名称。

以下是一些常见的元方法：

- `__add(a, b)`：定义当两个值进行加法操作时应该调用的函数。
- `__sub(a, b)`：定义当两个值进行减法操作时应该调用的函数。
- `__mul(a, b)`：定义当两个值进行乘法操作时应该调用的函数。
- `__div(a, b)`：定义当两个值进行除法操作时应该调用的函数。
- `__mod(a, b)`：定义当两个值进行模运算时应该调用的函数。
- `__pow(a, b)`：定义当进行指数运算（如`a^b`）时应该调用的函数。
- `__unm(a)`：定义当对一个值进行取负操作时应该调用的函数。
- `__lt(a, b)`：定义当比较两个值是否小于时应该调用的函数。
- `__le(a, b)`：定义当比较两个值是否小于或等于时应该调用的函数。
- `__eq(a, b)`：定义当比较两个值是否相等时应该调用的函数。
- `__tostring(a)`：定义当将值转换为字符串时应该调用的函数。
- `__index(table, key)`：定义当访问表的某个不存在的键时应该调用的函数。
- `__newindex(table, key, value)`：定义当给表的某个键赋值，但这个键原本不存在时应该调用的函数。
- `__call(func, ...)`：定义当尝试将某个值作为函数调用时应该调用的函数。

##### 使用元表和元方法

你可以使用`setmetatable`函数为Lua中的值设置元表。

一旦设置了元表，并且元表中定义了相应的元方法，那么当Lua尝试对这个值执行相应的操作时，就会调用这些元方法。

**举例子**

例如，如果你想让两个用户自定义的对象在相加时执行特定的逻辑，你可以为这两个对象的元表设置__add元方法，并指定一个当这两个对象相加时应该调用的函数。

元表和元方法为Lua提供了极高的灵活性和扩展性，使得Lua能够以一种非常自然和直观的方式来处理复杂的对象和操作。
